# 스토리 3번: 인수인계서 데이터 저장 및 관리 백엔드 - 기술설계서

## 개요
인수인계서 데이터 저장 및 관리 백엔드 시스템의 기술적 설계 문서

## 시스템 아키텍처

### 전체 아키텍처
```
[Frontend] → [API Gateway] → [Backend Services] → [Database Layer]
    ↓              ↓              ↓                    ↓
  React.js    Express.js    Node.js Services    PostgreSQL + MongoDB
```

### 데이터베이스 아키텍처
```
PostgreSQL (메타데이터)
├── users (사용자 정보)
├── handover_documents (인수인계서 메타데이터)
├── handover_versions (버전 관리)
├── handover_shares (공유 관리)
└── handover_comments (댓글 관리)

MongoDB (문서 데이터)
├── handover_content (인수인계서 본문)
└── handover_templates (템플릿 관리)
```

## 기술 스택

### Backend
- **Runtime**: Node.js 18+
- **Framework**: Express.js 4.x
- **Language**: TypeScript 5.x
- **ORM**: Prisma (PostgreSQL), Mongoose (MongoDB)
- **Validation**: Joi, Zod
- **Authentication**: JWT, Passport.js
- **Caching**: Redis 7.x

### Database
- **PostgreSQL**: 15+ (메타데이터, 관계형 데이터)
- **MongoDB**: 6.x (문서 데이터)
- **Redis**: 7.x (캐싱, 세션 관리)

### Infrastructure
- **Cloud**: Azure
- **Container**: Docker, Kubernetes
- **CI/CD**: GitHub Actions
- **Monitoring**: Azure Monitor, Application Insights

## 데이터베이스 설계

### PostgreSQL 스키마

#### 1. 사용자 테이블 (users)
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    full_name VARCHAR(100) NOT NULL,
    department VARCHAR(100),
    position VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    is_active BOOLEAN DEFAULT TRUE
);
```

#### 2. 인수인계서 메타데이터 테이블 (handover_documents)
```sql
CREATE TABLE handover_documents (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    author_id INTEGER REFERENCES users(id),
    status VARCHAR(50) DEFAULT 'draft', -- draft, in_progress, completed, archived
    priority VARCHAR(20) DEFAULT 'medium', -- low, medium, high, urgent
    category VARCHAR(100),
    tags TEXT[], -- PostgreSQL 배열 타입
    mongo_id VARCHAR(50) UNIQUE, -- MongoDB 문서 ID 참조
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    completed_at TIMESTAMP,
    archived_at TIMESTAMP
);
```

#### 3. 인수인계서 버전 관리 테이블 (handover_versions)
```sql
CREATE TABLE handover_versions (
    id SERIAL PRIMARY KEY,
    document_id INTEGER REFERENCES handover_documents(id),
    version_number INTEGER NOT NULL,
    mongo_id VARCHAR(50) NOT NULL, -- MongoDB 버전 문서 ID
    created_at TIMESTAMP DEFAULT NOW(),
    created_by INTEGER REFERENCES users(id),
    change_summary TEXT
);
```

#### 4. 인수인계서 공유 테이블 (handover_shares)
```sql
CREATE TABLE handover_shares (
    id SERIAL PRIMARY KEY,
    document_id INTEGER REFERENCES handover_documents(id),
    shared_with_user_id INTEGER REFERENCES users(id),
    permission_level VARCHAR(20) DEFAULT 'read', -- read, write, admin
    shared_at TIMESTAMP DEFAULT NOW(),
    shared_by INTEGER REFERENCES users(id),
    expires_at TIMESTAMP
);
```

#### 5. 인수인계서 댓글 테이블 (handover_comments)
```sql
CREATE TABLE handover_comments (
    id SERIAL PRIMARY KEY,
    document_id INTEGER REFERENCES handover_documents(id),
    author_id INTEGER REFERENCES users(id),
    content TEXT NOT NULL,
    parent_comment_id INTEGER REFERENCES handover_comments(id), -- 대댓글 지원
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    is_deleted BOOLEAN DEFAULT FALSE
);
```

### MongoDB 컬렉션

#### 1. 인수인계서 본문 컬렉션 (handover_content)
```javascript
{
  _id: ObjectId,
  document_id: Number, // PostgreSQL handover_documents.id 참조
  version: Number,
  content: {
    sections: [
      {
        id: String,
        title: String,
        content: String,
        order: Number,
        type: String // text, list, table, code, etc.
      }
    ],
    attachments: [
      {
        id: String,
        filename: String,
        filepath: String,
        file_size: Number,
        mime_type: String,
        uploaded_at: Date
      }
    ],
    metadata: {
      total_sections: Number,
      word_count: Number,
      last_modified_section: String
    }
  },
  created_at: Date,
  updated_at: Date,
  created_by: Number, // PostgreSQL users.id 참조
  updated_by: Number
}
```

#### 2. 인수인계서 템플릿 컬렉션 (handover_templates)
```javascript
{
  _id: ObjectId,
  name: String,
  description: String,
  category: String,
  template_content: {
    sections: [
      {
        id: String,
        title: String,
        placeholder: String,
        required: Boolean,
        type: String
      }
    ]
  },
  created_at: Date,
  created_by: Number,
  is_public: Boolean,
  usage_count: Number
}
```

## API 설계

### RESTful API 엔드포인트

#### 인수인계서 관리 API
```
GET    /api/handovers                    # 인수인계서 목록 조회
POST   /api/handovers                    # 인수인계서 생성
GET    /api/handovers/:id                # 인수인계서 상세 조회
PUT    /api/handovers/:id                # 인수인계서 수정
DELETE /api/handovers/:id                # 인수인계서 삭제
POST   /api/handovers/:id/versions       # 버전 생성
GET    /api/handovers/:id/versions       # 버전 목록 조회
```

#### 사용자 관리 API
```
GET    /api/users                        # 사용자 목록 조회
GET    /api/users/:id                    # 사용자 상세 조회
PUT    /api/users/:id                    # 사용자 정보 수정
GET    /api/users/:id/handovers          # 사용자 인수인계서 목록
```

#### 공유 및 권한 API
```
POST   /api/handovers/:id/share          # 인수인계서 공유
GET    /api/handovers/:id/shares         # 공유 목록 조회
DELETE /api/handovers/:id/shares/:shareId # 공유 삭제
```

#### 댓글 API
```
GET    /api/handovers/:id/comments       # 댓글 목록 조회
POST   /api/handovers/:id/comments      # 댓글 작성
PUT    /api/comments/:id                 # 댓글 수정
DELETE /api/comments/:id                 # 댓글 삭제
```

### API 응답 형식
```typescript
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  meta?: {
    page?: number;
    limit?: number;
    total?: number;
  };
}
```

## 서비스 레이어 설계

### 인수인계서 서비스
```typescript
export class HandoverService {
  async createHandover(data: CreateHandoverDto): Promise<HandoverDocument> {
    // 1. PostgreSQL에 메타데이터 저장
    const handover = await this.prisma.handoverDocument.create({
      data: {
        title: data.title,
        authorId: data.authorId,
        status: 'draft',
        mongoId: generateMongoId()
      }
    });

    // 2. MongoDB에 본문 저장
    const content = await this.mongoService.createContent({
      documentId: handover.id,
      version: 1,
      content: data.content,
      createdBy: data.authorId
    });

    return handover;
  }

  async getHandover(id: number): Promise<HandoverWithContent> {
    // 1. PostgreSQL에서 메타데이터 조회
    const handover = await this.prisma.handoverDocument.findUnique({
      where: { id },
      include: { author: true }
    });

    // 2. MongoDB에서 본문 조회
    const content = await this.mongoService.getContent(handover.mongoId);

    return { ...handover, content };
  }

  async updateHandover(id: number, data: UpdateHandoverDto): Promise<HandoverDocument> {
    // 트랜잭션 처리
    return await this.prisma.$transaction(async (tx) => {
      // 1. PostgreSQL 업데이트
      const handover = await tx.handoverDocument.update({
        where: { id },
        data: {
          title: data.title,
          status: data.status,
          updatedAt: new Date()
        }
      });

      // 2. MongoDB 업데이트
      await this.mongoService.updateContent(handover.mongoId, data.content);

      return handover;
    });
  }
}
```

## 보안 설계

### 인증 및 인가
```typescript
export const authenticateToken = (req: Request, res: Response, next: NextFunction) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  jwt.verify(token, process.env.JWT_SECRET!, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid token' });
    }
    req.user = user;
    next();
  });
};
```

### 데이터 암호화
```typescript
export class EncryptionService {
  private algorithm = 'aes-256-gcm';
  private key = crypto.scryptSync(process.env.ENCRYPTION_KEY!, 'salt', 32);

  encrypt(text: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.key);
    cipher.setAAD(Buffer.from('handover-data'));
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;
  }
}
```

## 성능 최적화

### 캐싱 전략
```typescript
export class CacheService {
  private redis: Redis;

  async getHandover(id: number): Promise<HandoverWithContent | null> {
    const cacheKey = `handover:${id}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }

    const handover = await this.handoverService.getHandover(id);
    if (handover) {
      await this.redis.setex(cacheKey, 3600, JSON.stringify(handover)); // 1시간 캐시
    }

    return handover;
  }
}
```

### 데이터베이스 최적화
```sql
-- PostgreSQL 인덱스
CREATE INDEX idx_handover_documents_author ON handover_documents(author_id);
CREATE INDEX idx_handover_documents_status ON handover_documents(status);
CREATE INDEX idx_handover_documents_created_at ON handover_documents(created_at);
CREATE INDEX idx_handover_documents_mongo_id ON handover_documents(mongo_id);
CREATE INDEX idx_handover_documents_tags ON handover_documents USING GIN(tags);

-- MongoDB 인덱스
db.handover_content.createIndex({ "document_id": 1, "version": 1 });
db.handover_content.createIndex({ "created_at": 1 });
db.handover_content.createIndex({ "content.sections.title": "text" });
```

## 모니터링 및 로깅

### 로깅 전략
```typescript
export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});
```

## 배포 및 인프라

### Docker 설정
```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

EXPOSE 3000

CMD ["npm", "start"]
```

### Kubernetes 설정
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: handover-backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: handover-backend
  template:
    metadata:
      labels:
        app: handover-backend
    spec:
      containers:
      - name: handover-backend
        image: handover-backend:latest
        ports:
        - containerPort: 3000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: url
        - name: MONGODB_URI
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: uri
```

## 테스트 전략

### 단위 테스트
```typescript
describe('HandoverService', () => {
  let handoverService: HandoverService;
  let mockPrisma: jest.Mocked<PrismaClient>;
  let mockMongoService: jest.Mocked<MongoService>;

  beforeEach(() => {
    mockPrisma = createMockPrismaClient();
    mockMongoService = createMockMongoService();
    handoverService = new HandoverService(mockPrisma, mockMongoService);
  });

  describe('createHandover', () => {
    it('should create handover successfully', async () => {
      const handoverData = {
        title: 'Test Handover',
        authorId: 1,
        content: { sections: [] }
      };

      mockPrisma.handoverDocument.create.mockResolvedValue({
        id: 1,
        title: 'Test Handover',
        authorId: 1,
        status: 'draft',
        mongoId: 'mongo123'
      });

      const result = await handoverService.createHandover(handoverData);

      expect(result).toBeDefined();
      expect(mockPrisma.handoverDocument.create).toHaveBeenCalled();
      expect(mockMongoService.createContent).toHaveBeenCalled();
    });
  });
});
```

## 보안 체크리스트

### 데이터 보안
- [ ] 민감한 데이터 필드 암호화
- [ ] 데이터베이스 연결 암호화 (TLS)
- [ ] 정기적인 보안 업데이트
- [ ] 접근 로그 모니터링

### API 보안
- [ ] JWT 토큰 검증
- [ ] Rate limiting 적용
- [ ] CORS 설정
- [ ] 입력 데이터 검증

### 인프라 보안
- [ ] 컨테이너 보안 스캔
- [ ] 네트워크 보안 그룹 설정
- [ ] 시크릿 관리 (Azure Key Vault)
- [ ] 정기적인 보안 감사
